---
title: "Project1"
author: "Kate Brown"
date: "2024-09-03"
output:
  html_document: default
  pdf_document: default
---


```{r}

library("here")
library("tidyverse")

# tests if a directory named "data" exists locally
if (!dir.exists(here("data"))) {
    dir.create(here("data"))
}

# saves data only once (not each time you knit a R Markdown)
if (!file.exists(here("data", "chocolate.RDS"))) {
    url_csv <- "https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2022/2022-01-18/chocolate.csv"
    chocolate <- readr::read_csv(url_csv)

    # save the file to RDS objects
    saveRDS(chocolate, file = here("data", "chocolate.RDS"))
}

chocolate = readRDS(here("data", "chocolate.RDS"))
as_tibble(chocolate)
```
```{r}
glimpse(chocolate)
```
```{r}
library(ggplot2)
library(dplyr)
```

**Part 1**

1. Make a histogram of the rating scores to visualize the overall distribution of scores. Change the number of bins from the default to 10, 15, 20, and 25. Pick on the one that you think looks the best. Explain what the difference is when you change the number of bins and explain why you picked the one you did.
```{r}
ggplot(chocolate, aes(x=rating)) + geom_histogram(
) #default is 30
ggplot(chocolate, aes(x=rating)) + geom_histogram(bins = 10)
ggplot(chocolate, aes(x=rating)) + geom_histogram(
bins = 15)
ggplot(chocolate, aes(x=rating)) + geom_histogram(
bins=20)
ggplot(chocolate, aes(x=rating)) + geom_histogram(bins=25
)
```
Changing the number of bins changes how many bars you will see on the histogram. I choose 15 bins because it shows that there are 2 rating numbers that were higher than the rest of the other ratings given. 

2. Consider the countries where the beans originated from. How many reviews come from each country of bean origin?
```{r}
reviewCount = chocolate %>%
  group_by(country_of_bean_origin) %>%
  summarise(numReviews = n())
  
print(reviewCount)

```
3. What is average rating scores from reviews of chocolate bars that have Ecuador as country_of_bean_origin in this dataset? For this same set of reviews, also calculate (1) the total number of reviews and (2) the standard deviation of the rating scores. Your answer should be a new data frame with these three summary statistics in three columns. Label the name of these columns mean, sd, and total.

```{r}
ecuador = chocolate %>%
  filter(country_of_bean_origin == "Ecuador") %>%
  summarise(mean = mean(rating), total = n(), sd = sd(rating)) 

print(ecuador)
  
```
4. Which company (name) makes the best chocolate (or has the highest ratings on average) with beans from Ecuador?

Amano, Benoit Nihant, Beschle, COmori, Durci, Pacari, The Smooth Chocolator
```{r}
chocolate %>%
  filter(rating == 4 & country_of_bean_origin == "Ecuador")

```

5. Calculate the average rating across all country of origins for beans. Which top 3 countries (for bean origin) have the highest ratings on average?

Top 3 countries with highest average rating: Tobago, Chine, Sao Tome & Principe
```{r}
average_rating = chocolate %>% 
  group_by(country_of_bean_origin) %>%
  summarise(average_rating = mean(rating)) %>%
  arrange(desc(average_rating))  %>%
  slice_head(n =3)

print(average_rating)

```
6. Following up on the previous problem, now remove any countries of bean origins that have less than 10 chocolate bar reviews. Now, which top 3 countries have the highest ratings on average?

Solomon Islands, Congo, Cuba 
```{r}
tenplus_reviews <- chocolate %>%
  group_by(country_of_bean_origin) %>%
  summarise(
    numReviews = n(),
    average_rating = mean(rating, na.rm = TRUE)
  ) %>%
  filter(numReviews >= 10) %>%
  arrange(desc(average_rating)) %>%
  slice_head(n =3)
  
print(tenplus_reviews)
```

7. For this last part, let’s explore the relationship between percent chocolate and ratings.
Use the functions in dplyr, tidyr, and lubridate to perform the following steps to the chocolate dataset:

-Identify the countries of bean origin with at least 50 reviews. Remove reviews from countries are not in this list.
-Using the variable describing the chocolate percentage for each review, create a new column that groups chocolate percentages into one of four groups: (i) <60%, (ii) >=60 to <70%, (iii) >=70 to <90%, and (iiii) >=90% (Hint check out the substr() function in base R and the case_when() function from dplyr – see example below).
-Using the new column described in #2, re-order the factor levels (if needed) to be starting with the smallest percentage group and increasing to the largest percentage group (Hint check out the fct_relevel() function from forcats).
-For each country, make a set of four side-by-side boxplots plotting the groups on the x-axis and the ratings on the y-axis. These plots should be faceted by country.

On average, which category of chocolate percentage is most highly rated? Do these countries mostly agree or are there disagreements?
```{r}
fiftyPlus_reviews = chocolate %>%
  group_by(country_of_bean_origin) %>%
  summarise(numReviews = n())%>%
  filter(numReviews >= 50) %>%
  pull(country_of_bean_origin)

fiftyPlusChocolates = chocolate %>%
  filter(country_of_bean_origin %in% fiftyPlus_reviews)

fiftyPlusRatingGroup = fiftyPlusChocolates %>%
  mutate(percentageGroup = case_when(
    cocoa_percent < 60 ~ "i", 
    cocoa_percent >= 60 & cocoa_percent < 70 ~ "ii", 
    cocoa_percent >= 70 & cocoa_percent < 90 ~ "iii", 
    cocoa_percent >= 90 ~ "iiii"
  )) %>%
  arrange(percentageGroup)


print(fiftyPlusRatingGroup)

ggplot(fiftyPlusRatingGroup, aes(x = percentageGroup, y = rating)) +
  geom_boxplot() +
  facet_wrap(~ country_of_bean_origin) +
  labs(x = "Cocoa Percentage Group", y = "Rating", title = "Boxplots of Ratings by Cocoa Percentage Group, Faceted by Country") 
```
Cocoa Percentage Group ii is most highly rated. Between all the countries there are a few disagreements with the highest rated cocoa percentage group, between groups ii and iii for majority of the countries. 

**Part 2**
Part 2: Join two datasets together
The goal of this part of the assignment is to join two datasets together. gapminder is a R package that contains an excerpt from the Gapminder data.

Tasks
1.Use this dataset it to create a new column called continent in our chocolate dataset that contains the continent name for each review where the country of bean origin is.
2.Only keep reviews that have reviews from countries of bean origin with at least 10 reviews.
3.Also, remove the country of bean origin named "Blend".
Make a set of violin plots with ratings on the y-axis and continents on the x-axis.

```{r}
chocolate=chocolate %>%
  mutate(continent = country_of_bean_origin)

library(gapminder)
gapminder_continent= gapminder %>%
  select(country, continent) %>%
  distinct()


countries_with_enough_reviews <- chocolate %>%
  filter(country_of_bean_origin != "Blend") %>%
  group_by(country_of_bean_origin) %>%
  filter (n() >= 10) %>%
  ungroup()


chocolate_part2 = countries_with_enough_reviews %>%
  left_join(gapminder_continent, by = c("country_of_bean_origin" = "country"))
```


```{r}
chocolate_part2 = chocolate_part2 %>%
  mutate(continent.y = case_when(
    country_of_bean_origin %in% c("Fiji", "Papua New Guinea", "Vanuatu", "Solomon Islands") & is.na(continent.y) ~ "Australia",
    country_of_bean_origin %in% c("Sao Tome", "Congo") & is.na(continent.y) ~ "Africa",
    country_of_bean_origin %in% c("Trinidad", "Belize", "Grenada", "St. Lucia", "U.S.A.") & is.na(continent.y) ~ "Americas",
    TRUE ~ continent.y  # Keep existing values
  ))
```


```{r}
# check if there is NA in that column 
#na_rows_continent = chocolate_part2 %>%
 # filter(is.na(continent))

ggplot(chocolate_part2, aes(x = continent.y, y = rating)) + geom_violin() +
  labs(x = "Continent", y = "Rating", title = "Violin Plot of Continents vs. Ratings")

```

**Part 3**
1. Create a new set of columns titled beans, sugar, cocoa_butter, vanilla, letchin, and salt that contain a 1 or 0 representing whether or not that review for the chocolate bar contained that ingredient (1) or not (0).
```{r}

chocolate_part3 = chocolate %>%
  select(review_date, ingredients, most_memorable_characteristics) %>%
  mutate(
    beans = as.integer(grepl("B", ingredients)), 
    sugar = as.integer(grepl("S", ingredients)), 
    cocoa_butter = as.integer(grepl ("C", ingredients)), 
    vanilla = as.integer(grepl("V", ingredients)),
    letchin = as.integer(grepl("L", ingredients)),
    salt = as.integer(grepl("Sa", ingredients)),
  )

print(chocolate_part3)

```
2. Create a new set of columns titled char_cocoa, char_sweet, char_nutty, char_creamy, char_roasty, char_earthy that contain a 1 or 0 representing whether or not that the most memorable characteristic for the chocolate bar had that word (1) or not (0). For example, if the word “sweet” appears in the most_memorable_characteristics, then record a 1, otherwise a 0 for that review in the char_sweet column (Hint: check out str_detect() from the stringr package).
```{r}
chocolate_part3 = chocolate_part3 %>%
  mutate(
    char_cocoa = as.integer(grepl("cocoa", most_memorable_characteristics)), 
    char_sweet = as.integer(grepl("sweet", most_memorable_characteristics)), 
    char_nutty = as.integer(grepl ("nutty", most_memorable_characteristics)), 
    char_creamy = as.integer(grepl("creamy", most_memorable_characteristics)),
    char_roasty = as.integer(grepl("roasty", most_memorable_characteristics)),
    char_earthy = as.integer(grepl("earthy", most_memorable_characteristics)),
  )



chocolate_part3 = subset(chocolate_part3, select = -c(ingredients, most_memorable_characteristics))

print(chocolate_part3)

```

3. For each year (i.e. review_date), calculate the mean value in each new column you created across all reviews for that year. (Hint: If all has gone well thus far, you should have a dataset with 16 rows and 13 columns).
```{r}
mean_chocolate_part3 = chocolate_part3 %>%
  group_by(review_date) %>%
  summarize (
    mean_beans = mean(beans, na.rm = TRUE),
    mean_sugar = mean(sugar, na.rm = TRUE),
    mean_cocoa_butter = mean(cocoa_butter, na.rm = TRUE),
    mean_vanilla = mean(vanilla, na.rm = TRUE),
    mean_letchin = mean(letchin, na.rm = TRUE),
    mean_salt = mean(salt, na.rm = TRUE), 
    mean_char_cocoa = mean(char_cocoa, na.rm = TRUE),
    mean_char_nutty = mean(char_nutty, na.rm = TRUE),
    mean_char_sweet = mean(char_sweet, na.rm = TRUE),
    mean_char_creamy = mean(char_creamy, na.rm = TRUE),
    mean_char_roasty = mean(char_roasty, na.rm = TRUE),
    mean_char_earthy = mean(char_earthy, na.rm = TRUE)
    
  )
print(mean_chocolate_part3)
```

4. Convert this wide dataset into a long dataset with a new feature and mean_score column.
```{r}
mean_chocolate_part3_long = mean_chocolate_part3 %>%
  pivot_longer(
    cols = starts_with("mean_"), 
    names_to = "feature", 
    values_to = "mean_score"
  )

print(mean_chocolate_part3_long)
```

**Part 4**
Use the functions in ggplot2 package to make a scatter plot of the mean_scores (y-axis) over time (x-axis). There should be one plot (facet) for each feature. For full credit, your plot should include:

1.An overall title for the plot and a subtitle summarizing key trends that you found. Also include a caption in the figure with your name.
2.Both the observed points for the mean_score, but also a smoothed non-linear pattern of the trend
3.All plots should be shown in the one figure
4. There should be an informative x-axis and y-axis label

```{r}
ggplot(mean_chocolate_part3_long, aes(x = review_date, y = mean_score)) + geom_point() + geom_smooth(colour = "purple")+ facet_wrap(~feature, scales = "free_y") + labs(x = "Review Date", y = "Mean Score", title = "Plot of chocolate ingredients and characteristics over time", caption = "Kate Brown", subtitle = "Over time the amount of letchin and vanilla and mention of creamy as a characteristic in reviews steadily decreased")
```
**Part 5**

```{r}

chocolate_part5 <- chocolate %>%
  mutate(cocoa_percent = str_remove(cocoa_percent, "%") %>% as.numeric())

percent_mean = chocolate_part5 %>%
  group_by(country_of_bean_origin) %>%
  summarise(avg_percent = mean(cocoa_percent))
  
print(percent_mean)



```



```{r}
percent_mean <- percent_mean %>%
  filter(country_of_bean_origin != "Blend") 

percent_mean = percent_mean %>%
  left_join(gapminder_continent, by = c("country_of_bean_origin" = "country"))
```


```{r}
percent_mean = percent_mean %>%
  mutate(continent = case_when(
    country_of_bean_origin %in% c("Fiji", "Papua New Guinea", "Vanuatu", "Solomon Islands", "Samoa", "Sulawesi", "Australia") ~ "Australia",
    country_of_bean_origin %in% c("Sao Tome", "Sao Tome & Principe", "Principe", "Congo", "Ivory Coast", "DR Congo") & is.na(continent) ~ "Africa",
    country_of_bean_origin %in% c("Trinidad", "Belize", "Grenada", "St. Lucia", "U.S.A.", "Tobago", "Martinique", "Suriname", "St.Vincent-Grenadines") & is.na(continent) ~ "Americas",
    country_of_bean_origin %in% c("Burma", "Sumatra") & is.na(continent) ~ "Asia",
    TRUE ~ continent  # Keep existing values
  ))
```



```{r}
ggplot(percent_mean, aes(x = country_of_bean_origin, y = avg_percent)) +
  geom_bar(stat = "identity", colour = "yellow", fill = "blue", linewidth = 1) + 
  facet_wrap(~ continent) +  
  theme_minimal(base_size = 17) +  
  scale_y_continuous(breaks = seq(0, 80, by = 4)) + 
  theme(
    axis.text.x = element_text(angle = 15, hjust = 1),  
    strip.text = element_text(size = 3, face = "bold"),  ,     aspect.ratio = 1 / 12  
  ) 
```
1. No title or axis labels makes it hard to understand what the graph is actually showing and what each axis represents. 
2. Angling the x-axis value to 15 degrees makes it very hard to read all the values being shown on that axis because all the words are overlapping
3. Making the text showing all the continents that are being graphed  size 3 makes the text really small and hard to read. This makes it difficult to see which graph is for which continent.
4. Making the line width 1 and outline of the bar colors yellow makes it hard to actually see the fill and and the yellow is very similar to the background color making it hard on the readers eye to tell the difference. 
5. Setting the base size to 17 makes the x and y axis much larger than the actual graph. With this adjustment the labels on the x and y axis are much larger than the contents on the graph.
6. Customizing the scale on the y access to range from 0 to 80 counting by 4 makes the values unreadable because there are so many values of a large size print trying to be fit on a small graph. 
7. Setting the aspect ratio to 1/12 makes the graph and long. This ultimately makes the axis harder to read and all the bars even smaller.



**Part 6**

```{r}


continents <- unique(percent_mean$continent)

continent_plots <- list()

for (continent in continents) {
  continent_data <- percent_mean %>% filter(continent == !!continent)
  
 
  plot <- ggplot(continent_data, aes(x = country_of_bean_origin, y = avg_percent)) +
    geom_bar(stat = "identity", colour = "black", fill = "lightblue", linewidth = 0.4) +
    theme_minimal(base_size = 10) +
    scale_y_continuous(breaks = seq(0, 80, by = 20)) +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
      plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
      plot.margin = margin(t = 10, r = 10, b = 10, l = 10)
    ) +
    labs(
      x = "Country of Bean Origin", 
      y = "Average Cocoa Percentage (%)", 
      title = paste("Average Cocoa Percent by Country of Bean Origin -", continent)
    )
  
  continent_plots[[continent]] <- plot
}


for (continent in names(continent_plots)) {
  print(continent_plots[[continent]])
}

```


1. I added a title of the entire graph and changed the title of the x and y axis to clearly identify what variables are being graphed. 
2. The y-axis goes from 0 to 80 by 20 instead of 4. This makes the y-axis numbers legible and easier to read. 
3. The color of the bars and now light blue which makes looking at the bars easier on readers eyes and the outline is black with a linewidth of 0.4 making it easier to see the separation between the bars. 
4. I changed the base size from 17 to 10 to makes the x and y titles and labels smaller and not bigger than the actual bar graph. 
5. I increased the aspect ratio to 1/3 which makes the graph not as long and skinny and easier to look at. 
6. Instead of using facet_wrap to show all the different continents I created separate graphs for each continent so that you can easily see what bar corresponds to what country of bean origin.
7. Angeling the x axis titles to 45 degrees instead of 15 makes it much easier to read each indivudal label since they are not overlapping. 

